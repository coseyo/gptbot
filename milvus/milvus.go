package milvus

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/coseyo/gptbot"
	"github.com/go-aie/xslices"
	"github.com/milvus-io/milvus-sdk-go/v2/client"
	"github.com/milvus-io/milvus-sdk-go/v2/entity"
)

const (
	pkName, idName, textName, documentIDName, embeddingName = "pk", "id", "text", "document_id", "embedding"
)

type Config struct {
	// CollectionName is the collection name.
	// This field is required.
	CollectionName string

	// CreateNew specifies whether to overwrite if the collection already exists.
	CreateNew bool

	// Addr is the address of the Milvus server.
	// Defaults to "localhost:19530".
	Addr string

	// Dim is the embedding dimension.
	// Defaults to 1536 (the dimension generated by OpenAI's Embedding API).
	Dim int
}

func (cfg *Config) init() {
	if cfg.Addr == "" {
		cfg.Addr = "localhost:19530"
	}
	if cfg.Dim == 0 {
		cfg.Dim = 1536
	}
}

type Milvus struct {
	client client.Client
	cfg    *Config
}

func NewMilvus(cfg *Config) (*Milvus, error) {
	cfg.init()
	ctx := context.Background()

	c, err := client.NewGrpcClient(ctx, cfg.Addr)
	if err != nil {
		return nil, err
	}

	m := &Milvus{
		client: c,
		cfg:    cfg,
	}

	if err := m.createAndLoadCollection(ctx, cfg.CreateNew); err != nil {
		return nil, err
	}

	return m, nil
}

func (m *Milvus) LoadJSON(ctx context.Context, filename string) error {
	data, err := os.ReadFile(filename)
	if err != nil {
		return err
	}

	var chunks []*gptbot.Chunk
	if err := json.Unmarshal(data, &chunks); err != nil {
		return err
	}

	chunkMap := make(map[string][]*gptbot.Chunk)
	for _, chunk := range chunks {
		chunkMap[chunk.DocumentID] = append(chunkMap[chunk.DocumentID], chunk)
	}

	return m.Insert(ctx, chunkMap)
}

func (m *Milvus) Insert(ctx context.Context, chunks map[string][]*gptbot.Chunk) error {
	var idList []string
	var textList []string
	var documentIDList []string
	var embeddingList [][]float32
	for _, chunkList := range chunks {
		for _, chunk := range chunkList {
			idList = append(idList, chunk.ID)
			textList = append(textList, chunk.Text)
			documentIDList = append(documentIDList, chunk.DocumentID)
			embeddingList = append(embeddingList, xslices.Float64ToNumber[float32](chunk.Embedding))
		}
	}

	idCol := entity.NewColumnVarChar(idName, idList)
	textCol := entity.NewColumnVarChar(textName, textList)
	documentIDCol := entity.NewColumnVarChar(documentIDName, documentIDList)
	embeddingCol := entity.NewColumnFloatVector(embeddingName, m.cfg.Dim, embeddingList)

	_, err := m.client.Insert(ctx, m.cfg.CollectionName, "", idCol, textCol, documentIDCol, embeddingCol)
	return err
}

// Query searches similarities of the given embedding with default consistency level.
func (m *Milvus) Query(ctx context.Context, embedding gptbot.Embedding, topK int) ([]*gptbot.Similarity, error) {
	float32Emb := xslices.Float64ToNumber[float32](embedding)
	vec2search := []entity.Vector{
		entity.FloatVector(float32Emb),
	}

	param, _ := entity.NewIndexFlatSearchParam()
	result, err := m.client.Search(
		ctx,
		m.cfg.CollectionName,
		nil,
		"",
		[]string{idName, textName, documentIDName},
		vec2search,
		embeddingName,
		entity.L2,
		topK,
		param,
	)
	if err != nil {
		return nil, err
	}

	if len(result) == 0 {
		return nil, nil
	}

	return constructSimilaritiesFromResult(&result[0])
}

// Delete deletes the chunks belonging to the given documentIDs.
// As a special case, empty documentIDs means deleting all chunks.
func (m *Milvus) Delete(ctx context.Context, documentIDs ...string) error {
	// To delete all chunks, we drop the old collection and create a new one.
	if len(documentIDs) == 0 {
		if err := m.client.ReleaseCollection(ctx, m.cfg.CollectionName); err != nil {
			return err
		}
		if err := m.client.DropCollection(ctx, m.cfg.CollectionName); err != nil {
			return err
		}
		return m.createAndLoadCollection(ctx, true)
	}

	expr := fmt.Sprintf(`document_id in ["%s"]`, strings.Join(documentIDs, `", "`))
	result, err := m.client.Query(ctx, m.cfg.CollectionName, nil, expr, []string{pkName})
	if err != nil {
		return err
	}

	var pkCol *entity.ColumnInt64
	for _, field := range result {
		if field.Name() == pkName {
			if c, ok := field.(*entity.ColumnInt64); ok {
				pkCol = c
			}
		}
	}

	if len(pkCol.Data()) == 0 {
		return nil
	}
	return m.client.DeleteByPks(ctx, m.cfg.CollectionName, "", pkCol)
}

func (m *Milvus) createAndLoadCollection(ctx context.Context, createNew bool) error {
	if err := m.createCollection(ctx, createNew); err != nil {
		return err
	}
	return m.client.LoadCollection(ctx, m.cfg.CollectionName, false)
}

func (m *Milvus) createCollection(ctx context.Context, createNew bool) error {
	has, err := m.client.HasCollection(ctx, m.cfg.CollectionName)
	if err != nil {
		return err
	}

	if has && !createNew {
		return nil
	}

	if has {
		_ = m.client.DropCollection(ctx, m.cfg.CollectionName)
	}

	// The collection does not exist, so we need to create one.

	schema := &entity.Schema{
		CollectionName: m.cfg.CollectionName,
		AutoID:         true,
		Fields: []*entity.Field{
			{
				Name:       pkName,
				DataType:   entity.FieldTypeInt64,
				PrimaryKey: true,
				AutoID:     true,
			},
			{
				Name:     idName,
				DataType: entity.FieldTypeVarChar,
				TypeParams: map[string]string{
					entity.TypeParamMaxLength: fmt.Sprintf("%d", 65535),
				},
			},
			{
				Name:     textName,
				DataType: entity.FieldTypeVarChar,
				TypeParams: map[string]string{
					entity.TypeParamMaxLength: fmt.Sprintf("%d", 65535),
				},
			},
			{
				Name:     documentIDName,
				DataType: entity.FieldTypeVarChar,
				TypeParams: map[string]string{
					entity.TypeParamMaxLength: fmt.Sprintf("%d", 65535),
				},
			},
			{
				Name:     embeddingName,
				DataType: entity.FieldTypeFloatVector,
				TypeParams: map[string]string{
					entity.TypeParamDim: fmt.Sprintf("%d", m.cfg.Dim),
				},
			},
		},
	}

	// Create collection with consistency level, which serves as the default search/query consistency level.
	if err := m.client.CreateCollection(ctx, schema, 2, client.WithConsistencyLevel(entity.ClBounded)); err != nil {
		return err
	}

	// Create index "IVF_FLAT".
	idx, err := entity.NewIndexIvfFlat(entity.L2, 128)
	if err != nil {
		return err
	}
	return m.client.CreateIndex(ctx, m.cfg.CollectionName, embeddingName, idx, false)
}

func constructSimilaritiesFromResult(result *client.SearchResult) ([]*gptbot.Similarity, error) {
	var idCol *entity.ColumnVarChar
	var textCol *entity.ColumnVarChar
	var documentIDCol *entity.ColumnVarChar
	for _, field := range result.Fields {
		switch field.Name() {
		case idName:
			if c, ok := field.(*entity.ColumnVarChar); ok {
				idCol = c
			}
		case textName:
			if c, ok := field.(*entity.ColumnVarChar); ok {
				textCol = c
			}
		case documentIDName:
			if c, ok := field.(*entity.ColumnVarChar); ok {
				documentIDCol = c
			}
		}
	}

	var similarities []*gptbot.Similarity
	for i := 0; i < result.ResultCount; i++ {
		id, err := idCol.ValueByIdx(i)
		if err != nil {
			return nil, err
		}
		text, err := textCol.ValueByIdx(i)
		if err != nil {
			return nil, err
		}
		documentID, err := documentIDCol.ValueByIdx(i)
		if err != nil {
			return nil, err
		}

		similarities = append(similarities, &gptbot.Similarity{
			Chunk: &gptbot.Chunk{
				ID:         id,
				Text:       text,
				DocumentID: documentID,
			},
			Score: float64(result.Scores[i]),
		})
	}

	return similarities, nil
}
